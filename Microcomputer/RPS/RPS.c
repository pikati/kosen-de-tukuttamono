/***********************************************************************/
/*                                                                     */
/*  FILE        :RPS.c                                                 */
/*  DATE        :Tue, Jan 17, 2017                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :H8/3687                                               */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.16).    */
/*                                                                     */
/***********************************************************************/
//Rock-paper-scissors
#include "iodefine.h"
#include "lcd_func.h"                  
#include <machine.h>   

void main(void);
#ifdef __cplusplus
extern "C" {
void abort(void);
}
#endif

#define WIN  1
#define LOSE 2
#define DRAW 3

int num_game = 3;			//今やってるゲームの指定をする
int num_win = 0;			//自分の勝ち数
int num_lose = 0;			//自分の負け数
int flag_game = 0;			//どのスイッチを押したかのフラグ
int flag_timer = 0;
int flag_transmission = 0;	//通信するかのフラグ
int flag_FPend = 0;
int game_end = 0;			//それぞれのゲームが終わると1になり、次のゲームにすすむ

int set_count = 10;
int TR_count = 0;
//ジャンケンの勝敗を決めるためのグローバル変数
int myself;	//ジャンケンの自分の手
int rival;	//ジャンケンの相手の手

unsigned char RevDT;

//空ループを発生させる関数
void wait(unsigned int count)
{
	unsigned int i, j;
	
	for(i=0; i<=count; i++){
		for(j=0; j<=50000; j++){
			;
		}
	}
}

//ｹﾞｰﾑのﾗｲﾝﾅｯﾌﾟを表示する関数
void indicate_lineup(void)
{
	lcd_init();
	lcd_xy(1, 1);
	lcd_puts("1:");
	lcd_puts("ｼﾞｬﾝｹﾝ ");
	lcd_puts("2:");
	lcd_puts("ﾊﾔｵｼ ");
	lcd_xy(1, 2);
	lcd_puts("3:");
	lcd_puts("ﾁｷﾝﾚｰｽ");
}

//ジャンケンゲームの説明を表示する関数
void description_RPS(){
	lcd_xy(1,1);
	lcd_puts("  ;              ");
	lcd_xy(1,2);
	lcd_puts("                ");
	lcd_xy(1,1);
	lcd_puts("ﾊｼﾞﾒﾉｹﾞｰﾑﾊ");
	lcd_xy(1,2);
	lcd_puts("ｼﾞｬﾝｹﾝｹﾞｰﾑﾃﾞｽ");
	wait(200);
	lcd_xy(1,1);
	lcd_puts("          ");
	lcd_xy(1,2);
	lcd_puts("             ");
	lcd_xy(1,1);
	lcd_puts("ｾﾂﾒｲｶﾞｵﾜｯﾀﾗ");
	lcd_xy(1,2);
	lcd_puts("ｽｲｯﾁﾉﾋﾀﾞﾘｶﾗ");
	wait(200);
	lcd_xy(1,1);
	lcd_puts("           ");
	lcd_xy(1,2);
	lcd_puts("           ");
	lcd_xy(1,1);
	lcd_puts("ｸﾞｰ ﾁｮｷ ﾊﾟｰ");
	lcd_xy(1,2);
	lcd_puts("ｺﾚﾃﾞｼﾞｬﾝｹﾝｦｼﾏｽ");
	wait(200);
	lcd_xy(1,1);
	lcd_puts("            ");
	lcd_xy(1,2);
	lcd_puts("              ");
	lcd_xy(1,1);
	lcd_puts("SW4ｦｵｼﾀﾗ");
	lcd_xy(1,2);
	lcd_puts("ｱｲﾃﾄｼﾞｬﾝｹﾝｦｼﾏｽ");
	wait(200);
	lcd_xy(1,1);
	lcd_puts("         ");
	lcd_xy(1,2);
	lcd_puts("              ");
	lcd_xy(1,1);
	lcd_puts("ﾄﾞﾁﾗｶｶﾞｶﾂﾏﾃﾞ");
	lcd_xy(1,2);
	lcd_puts("ｱｲﾃﾄｼﾞｬﾝｹﾝｦｼﾏｽ");
	wait(200);
	lcd_xy(1,1);
	lcd_puts("            ");
	lcd_xy(1,2);
	lcd_puts("              ");
	lcd_xy(1,1);
	lcd_puts("ｿﾚﾃﾞﾊ");
	lcd_xy(1,2);
	lcd_puts("ｽﾀｰﾄ!");
	wait(200);
	lcd_xy(1,1);
	lcd_puts("     ");
	lcd_xy(1,2);
	lcd_puts("      ");
}

//早押しゲームの説明を表示する関数
void description_FP()
{
	lcd_xy(1,1);
	lcd_puts("ﾂｷﾞﾉｹﾞｰﾑﾊ");
	lcd_xy(1,2);
	lcd_puts("ﾊﾔｵｼｹﾞｰﾑﾃﾞｽ");
	wait(200);
	lcd_xy(1,1);
	lcd_puts("       ");
	lcd_xy(1,2);
	lcd_puts("           ");
	lcd_xy(1,1);
	lcd_puts("ﾌﾞｻﾞｰｶﾞﾅｯﾀｱﾄﾆ");
	lcd_xy(1,2);
	lcd_puts("sw1ｦｻｷﾆｵｼﾀﾎｳﾉ");
	wait(200);
	lcd_xy(1,1);
	lcd_puts("             ");
	lcd_xy(1,2);
	lcd_puts("             ");
	lcd_xy(1,1);
	lcd_puts("ｶﾁﾃﾞｽ!!!");
	lcd_xy(1,2);
	lcd_puts("ｶﾁﾃﾞｽ!!!");
	wait(200);
	lcd_xy(1,1);
	lcd_puts("        ");
	lcd_xy(1,2);
	lcd_puts("        ");
	lcd_xy(1,1);
	lcd_puts("SW4ｦｵｼﾀﾗ");
	lcd_xy(1,2);
	lcd_puts("ｽﾀｰﾄ!");
	wait(200);
	lcd_xy(1,1);
	lcd_puts("           ");
	lcd_xy(1,2);
	lcd_puts("     ");
}

//チキンレースの説明を表示
void description_TR()
{
	lcd_puts("ｱﾄﾃﾞ");
	lcd_xy(1,2);
	lcd_puts("ｶｷﾏｽ");
	wait(200);
	lcd_xy(1,1);
	lcd_puts("           ");
	lcd_xy(1,2);
	lcd_puts("     ");
}

//初期化等の処理
void Init()
{
	
	lcd_init();				//LCD初期化
	
	set_imask_ccr(1);		//割込の禁止
	
	IO.PMR1.BYTE = 0xF8;	//ポート1を割込入力に設定
	IEGR1.BYTE = 0x70;		//割込を立下がりエッジで検出に設定
	IENR1.BYTE = 0x1F;		//外部端子割込を許可
	IRR1.BYTE = 0x30;		//割込の要求フラグをクリア
	TB1.TMB1.BIT.RLD = 0;	//インターバルタイマを選択
	TB1.TMB1.BIT.CKS = 1;	//Φ/2048クロックに設定
	IRR2.BIT.IRRTB1 = 0;	//割り込みフラグをクリア
	IENR2.BIT.IENTB1 = 1;	//オーバーフロー割り込みの許可
	TB1.TLB1 = 0;			//TCB1の初期値を0に設定する
	
	set_imask_ccr(0);		//割込の許可
	
	SCI3_2.SCR3.BIT.RE = 0;	//受信動作の禁止
	SCI3_2.SCR3.BIT.TE = 0;	//送信動作の禁止
	//SCI3_2.SCR3.BIT.RIE = 0;//受信割込の禁止
	//SCI3_2.SCR3.BIT.TIE = 0;//送信割込の禁止
	
	SCI3_2.SMR.BYTE = 0x00;	//通信フォーマットの設定
	SCI3_2.BRR = 64;		//ビットレートを600(bit/s)に設定
	SCI3_2.TDR = 0x00;		//送信のバッファの初期化
	SCI3_2.RDR = 0x00;		//受信のバッファの初期化
	
	SCI3_2.SSR.BIT.OER = 0;	//各受信エラーフラグの初期化
	SCI3_2.SSR.BIT.FER = 0;	
	SCI3_2.SSR.BIT.PER = 0;	
	
	wait(2);				//少し待ちを入れる
	
	SCI3_2.SCR3.BIT.RE = 1;	//受信動作の許可
	SCI3_2.SCR3.BIT.TE = 1;	//送信動作の許可
	SCI3_2.SCR3.BIT.RIE = 1;//受信割込の許可
	//SCI3_2.SCR3.BIT.TIE = 1;//送信割込の許可
	
	indicate_lineup();
	wait(150);
	
//	description_RPS();
}

//LCDの最終結果を表示する関数
void indicate_result(void)
{
	lcd_init();
	lcd_xy(1,1);
	lcd_puts("ｼﾞﾌﾞﾝ   :   ｱｲﾃ");
	
	lcd_xy(1,7);
	lcd_dataout(num_win);
	lcd_xy(1,11);
	lcd_dataout(num_lose);
	
	lcd_xy(1,2);
	if(num_win > num_lose){
		lcd_puts("YOU WIN!");
	}
	else{
		lcd_puts("YOU LOSE...");		
	}
	while(1);
}

//LCDに勝敗を表示する関数
void indicate_WL(int wl)
{
	lcd_init();
	lcd_xy(1,2);
	if(wl == WIN){
		lcd_puts("YOU WIN!");
		num_win++;
		game_end = 1;
	}
	else if(wl == LOSE){
		lcd_puts("YOU LOSE...");
		num_lose++;		
		game_end = 1;
	}
	else if(wl == DRAW){
		lcd_puts("DRAW");
		lcd_xy(1,2);
		lcd_puts("ﾜﾀｼ:    ｱｲﾃ:    ");
		lcd_xy(5,2);
		lcd_dataout(myself);
		lcd_xy(13,2);
		lcd_dataout(rival);
	}	
	myself = 0;
	rival = 0;
	wait(200);
	
	lcd_xy(1,1);
	lcd_puts("                ");
	lcd_xy(1,2);
	lcd_puts("                ");
}

//LCDにｼﾞｬﾝｹﾝのﾃﾞｰﾀを表示する関数
void indicate_RPS(int rps)
{
	lcd_init();
	lcd_xy(1,1);
	switch(rps){
		case 1: lcd_puts("ｸﾞｰ"); break;
		case 2: lcd_puts("ﾁｮｷ"); break;
		case 3: lcd_puts("ﾊﾟｰ"); break;
	}
}
//ｼﾞｬﾝｹﾝの勝敗を決める関数
void decide_WL_of_RPS()
{
	switch(myself){
		case 1: switch(rival){
					case 1: indicate_WL(DRAW); break;
					case 2: indicate_WL(WIN);  
							num_win++;		   break;	
					case 3: indicate_WL(LOSE); 
							num_lose++;		   break;
				}
				break;		
		case 2: switch(rival){
					case 1: indicate_WL(LOSE); 
							num_lose++;   	   break;
					case 2: indicate_WL(DRAW); break;	
					case 3: indicate_WL(WIN);  
							num_win++;		   break;
				}
				break;
		case 3: switch(rival){
					case 1: indicate_WL(WIN);  
							num_win++;		   break;
					case 2: indicate_WL(LOSE); 
							num_lose++;		   break;	
					case 3: indicate_WL(DRAW); break;
				}
				break;				
	}
	game_end = 1;
}

//勝敗を決める関数
void decide_WIN_or_LOSE()
{
	switch (num_game){
		case 3: decide_WL_of_RPS(); break;
		case 2: indicate_WL(LOSE); break;	//早押しは、受信した＝押すのが遅れた、なのでこちら負け
		case 1: indicate_WL(WIN); break;	//チキンレースは、受信した結果0になったら相手が0にした、なのでこちらの勝ち
	} 
}	

//受信時に処理する関数
void func_sci()
{
	/*
	if(SCI3_2.SSR.BIT.RDRF == 1){
		rival = SCI3_2.RDR;	//相手のデータを保持
		SCI3_2.SSR.BIT.RDRF = 0;
	}
	*/
	
	if(SCI3_2.SSR.BIT.RDRF == 1){
		RevDT = SCI3_2.RDR;
	
		//ジャンケン時のみ相手から受信しても自分が送信していないなら次の処理に進まない
		if(num_game == 3){
			while(flag_transmission == 0){
				;
			}
		}
		//チキンレース時のみset_countが0になるまで勝敗を決めない
		else if(num_game == 1){
			
			if(RevDT == 0x01){
				set_count -= 1;	
			}
			else if(RevDT == 0x02){
				set_count -= 2;
			}
			
			if(set_count < 0){
				set_count = 0;
			}
			
			//0になるまでチキンレースを続ける
			if(set_count != 0){
				flag_transmission = 0;
				return;
			}
		}
		
		flag_transmission = 0;	
		
		if(RevDT == 0x01){
			rival = 1;			//ジャンケン時の相手の手
			decide_WIN_or_LOSE();
		}
		else if(RevDT== 0x02){
			rival = 2;			//ジャンケン時の相手の手
			decide_WIN_or_LOSE();
		}
		else if(RevDT == 0x03){
			rival = 3;			//ジャンケン時の相手の手
			decide_WIN_or_LOSE();
		}
		else if(RevDT == 0x04){
			decide_WIN_or_LOSE();
		}

		SCI3_2.SSR.BIT.RDRF = 0;
	}

	else{
		SCI3_2.SSR.BIT.OER = 0;
		SCI3_2.SSR.BIT.FER = 0;
		SCI3_2.SSR.BIT.PER = 0;	
	}
}

//早押しゲームの時間を計測する関数
void TIMER_B1()
{
	static unsigned int count = 0;//1秒を数えるための変数
	static unsigned int SetSecond = 10;//セット時間
	
	//flagが1のときにタイマーが動作する
	if(flag_timer == 1)
	{
		count++;
		
		//1秒たったら
		if(count==38)
		{
			count=0;
			SetSecond--;
			//時間が0になったとき
			if(SetSecond == 0)
			{
				IO.PDR2.BIT.B0 = 1;
				flag_FPend = 1;		//これ以降SW1を押すとゲームが終了する
				flag_timer = 0;
			}
		}
	}
	IRR2.BIT.IRRTB1 = 0;
}


//////////////スイッチ関係の関数//////////////

//じゃんけんゲーム時のSW1の処理
void RPS1()
{
	myself = 1;
	indicate_RPS(1);
}

//じゃんけんゲーム時のSW2の処理
void RPS2()
{
	myself = 2;
	indicate_RPS(2);
}

//じゃんけんゲーム時のSW3の処理
void RPS3()
{
	myself = 3;
	indicate_RPS(3);
}

//早押しゲーム時のSW1の処理
void FP1()
{
	if(flag_FPend == 1)
	{
		flag_game = 1;
		flag_transmission = 1;
		indicate_WL(WIN);//勝ちの結果表示
		flag_FPend = 0;
	}
}

//早押しゲーム時のSW2の処理
void FP2()
{
	flag_timer = 1;
}

//チキンレースのSW1の処理
void TR1()
{
	TR_count = 1;
}

//チキンレースのSW2の処理
void TR2()
{
	TR_count = 2;
}

void IRQ_SW1(void)
{
	flag_game = 1;
	lcd_xy(1,1);
	lcd_puts("aaaa"); 
	//いまのゲームに応じて処理を変化させる
	switch(num_game){
		lcd_xy(1,2); 
	lcd_puts("aaaa");
		case 3: RPS1();break;
		case 2: FP1(); break;
		case 1: TR1(); break;
	}
	IRR1.BIT.IRRI0 = 0;
}

void IRQ_SW2(void)
{
	flag_game = 2;
	//いまのゲームに応じて処理を変化させる
	switch(num_game){
		case 3: RPS2(); break;
		case 2: FP2(); break;
		case 1: TR2(); break;
	}
	IRR1.BIT.IRRI1 = 0;
}

void IRQ_SW3(void)
{
	flag_game = 3;
	//いまのゲームに応じて処理を変化させる
	switch(num_game){
		case 3: RPS3(); break;
	}
	IRR1.BIT.IRRI2 = 0;
}

void IRQ_SW4(void)
{
	IRR1.BIT.IRRI3 = 0;
	if(num_game == 1){

		//SW1を押していたら1だけ、SW2を押していたら2だけset_countを減らす
		set_count -= TR_count;
	
		//減らした結果、0未満になたっら
		if(set_count < 0){
			set_count = 0;
			
			lcd_xy(1,1);
			lcd_puts("ﾉｺﾘ ");
			lcd_xy(5,1);
			indicate_WL(LOSE);
		}
	
		if(set_count >= 10){
			lcd_dataout(set_count);	
		}
		else{
			lcd_puts(" ");
			lcd_dataout(set_count);
		}
		
	}
	flag_transmission = 1;
}

void main(void)
{	
	Init();
	
	while(1){
		//SWが押されていて、送信データがある時
		if(flag_game != 0 && flag_transmission == 1 && SCI3_2.SSR.BIT.TDRE == 1){
			
			myself = flag_game;	//自分のデータを保持
			
			switch(flag_game){	//caseに応じて送信のバッファに値を入力
				case 1: SCI3_2.TDR = 0x01; 
					 break;
				case 2: SCI3_2.TDR = 0x02; 
					 break;
				case 3: SCI3_2.TDR = 0x03;
					 break;
				case 4: SCI3_2.TDR = 0x04;
					 break;
			}
			flag_game = 0;
		}
		
		if(num_game > 0 && game_end == 1){	//ゲーム回数が0になるまで繰り返す
			num_game--;
			game_end = 0;
			if(num_game == 2){
				description_FP();
			}
			else if(num_game == 1){
				description_TR();
			}
		}
		else if(num_game == 0){				//最終結果を表示
			indicate_result();	
		}
	}
}

#ifdef __cplusplus
void abort(void)
{

}
#endif